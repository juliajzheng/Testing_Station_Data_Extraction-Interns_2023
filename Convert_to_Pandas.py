import math
from pprint import pprint
from turtle import color
import numpy as np
import pandas as pd
import time
import sys
import os
from glob import glob
import csv
import matplotlib.pyplot as plt
import scipy
import statistics as stat
import bisect
import json
# import yaml ''' Switch to Python 3.8 to access yaml '''


from scipy.optimize import leastsq
from scipy.optimize import curve_fit

# user written functions/files
from MR3_MR4_LorentzApprox import *
from FSR_GroupIndex import *

'''
This is a parser function to read data generated by Maple Leaf Photonic 
Testing station. This function is written to ensure that the data is easily readable by Python 

This function reads the MLP output .csv file and exports another .csv file which is 
easy to ready via pandas. 
'''

def Convert_to_Pandas (folder_path):
  PATH = folder_path
  EXT = "*.csv"
  all_csv_files = [file
                  for path, subdir, files in os.walk(PATH)
                  for file in glob(os.path.join(path, EXT))] #type: ignore

  Meta_data = ['Device ID', 'Laser power','Device coordinates (gds)']
  data = ['wavelength', 'channel_1', 'channel_2']

  print('This is the file path: ',all_csv_files)

  for file_path in all_csv_files:                 # Finding the path to CSV file
    if 'Pandas' not in file_path:
      with open(file_path, newline='') as csvfile:  # Opening the CSV file 
        
        data_string = str()
        var = list()
        csv_data = csv.reader(csvfile)              # Read the CSV file 
        for row in csv_data:                        # Reading every row in the CSV file 
          row_val = ' '.join(row)                   # Reading row as one long string 
          
          for var_meta_data in Meta_data:           # Capturing Meta data 
            if var_meta_data in (row_val):
              data_string= " ".join([data_string, row_val.split('\t')[-1]])

          for val_data in data:                     # Capturing the Data    
            if val_data == row[0]:        
              for i in range(1,len(row)):
                var.append(float(row[i]))

        data_string = data_string.split(" ")
        Captured_Data = dict()
        
        Captured_Data['Device-ID'] = data_string[2]
        Captured_Data['X-Coordinate'] = float(data_string[3])
        Captured_Data['Y-Coordinate'] = float(data_string[5])
        Captured_Data['Laser-Power(dB)'] = float(data_string[6])
        Captured_Data['Wavelength'] = var[0:int(len(var)/3)]
        Captured_Data['Channel-1'] = var[int(len(var)/3):2*int(len(var)/3)]
        Captured_Data['Channel-2'] = var[2*int(len(var)/3): int(len(var))]

        # Editing the file with new path 
        path = (file_path.split('\\'))
        path[-1] = 'Pandas_'+file_path.split('\\')[-1]
        path = '\\'.join(path)

        # Rewriting data to csv
        data_to_write = pd.DataFrame(Captured_Data)
        data_to_write.to_csv(path,index=False,header=True)     
  return ()

def Channel1_Sep(folder_path):
  import matplotlib.pyplot as plt
  PATH = folder_path
  EXT = "*.csv"
  all_csv_files = [file
                  for path, subdir, files in os.walk(PATH)
                  for file in glob(os.path.join(path, EXT))]
  
  # for file_path in all_csv_files:                 # Finding the path to CSV file
  #   if 'Pandas' in file_path:
  #     df = pd.read_csv(file_path)#, header=None)    
  #     xData = df['Wavelength']
  #     yData = df['Channel-1']
  #     xFilterData, yFilterData = Filter_Data(xData= xData, yData= yData, xStart=1535, xStop= 1560)
  #     xFilterData = xFilterData.to_numpy()
  #     yFilterData = yFilterData.to_numpy()
  
  for file_path in all_csv_files:
    df = pd.read_csv(file_path)#, header=None)   
    if 'X-Coordinate' > min(df['Wavelength']) & 'Y-Coordinate'<max(df['Channel-1']):
      folder_path.plot(False)
    else:
      folder_path.plot(True)
  return()  
  
'''
Plotting all the  necessary results 

'''
def Plot_All_Pandas (folder_path):
  PATH = folder_path
  EXT = "*.csv"
  all_csv_files = [file
                  for path, subdir, files in os.walk(PATH)
                  for file in glob(os.path.join(path, EXT))]
  #filter loop here??

  fig, axs = plt.subplots(2, 3, figsize=(15, 10))
  ''' Channel 1 output result'''
  Legend_lables = list()
  for file_path in all_csv_files:                 # Finding the path to CSV file
    if 'Pandas' in file_path:
      df = pd.read_csv(file_path)#, header=None)    
      # axs[0].plot(df['Wavelength'], df['Laser-Power(dB)'], color = 'green')
      axs[0,0].plot(df['Wavelength'], df['Channel-1'])#type: ignore
      legend_val = df['Device-ID'][0]
      Legend_lables= np.append(Legend_lables, legend_val)

  axs[0,0].set_title('Channel-1')#type: ignore
  # axs[0,0].legend(Legend_lables, loc='center left', bbox_to_anchor=(1, 0.5),fontsize = 7)
  axs[0,0].set_ylim([-55, 10])#type: ignore
  axs[0,0].set_ylabel("Transmission (dB)")#type: ignore
  axs[0,0].set_xlabel("Wavelength (nm)")#type: ignore

  ''' Channel 2 output result'''
  Legend_lables = list()
  for file_path in all_csv_files:                 # Finding the path to CSV file
    if 'Pandas' in file_path:
      df = pd.read_csv(file_path)#, header=None)    
      # axs[1].plot(df['Wavelength'], df['Laser-Power(dB)'], color = 'green')
      axs[0,1].plot(df['Wavelength'], df['Channel-2'])#type: ignore
      legend_val = df['Device-ID'][0]
      Legend_lables= np.append(Legend_lables, legend_val)

  axs[0,1].set_title('Channel-2')#type: ignore
  # axs[0,1].legend(Legend_lables, loc='center left', bbox_to_anchor=(0,1, 0.5),fontsize = 7)
  axs[0,1].set_ylim([-55, 10])#type: ignore
  axs[0,1].set_ylabel("Transmission (dB)")#type: ignore
  axs[0,1].set_xlabel("Wavelength (nm)")#type: ignore

  ''' Location of the Device on the chip '''
  Legend_lables = list()
  for file_path in all_csv_files:                 # Finding the path to CSV file
    if 'Pandas' in file_path:
      df = pd.read_csv(file_path)#, header=None)    
      axs[0,2].plot(df['X-Coordinate'][0], df['Y-Coordinate'][0], #type: ignore
              color = 'red', marker='o', markerfacecolor='green')
      legend_val = df['Device-ID'][0]
      true_legend = legend_val.split('_')
      true_legend= '_'.join([true_legend[1],true_legend[2]])
      Legend_lables= np.append(Legend_lables, true_legend)
      
  axs[0,2].set_title('Selected Devices')  # type: ignore
  # axs[0,2].legend(Legend_lables, loc='center left', bbox_to_anchor=(1, 0.5),fontsize = 7)
  axs[0,2].set_xlim([-4600, 4600])#type: ignore
  axs[0,2].set_ylim([-4600, 4600])#type: ignore
  axs[0,2].set_ylabel("Y-Axis")#type: ignore
  axs[0,2].set_xlabel("X-Axis")#type: ignore


  ''' Channel 1 output result'''
  Legend_lables = list()
  for file_path in all_csv_files:                 # Finding the path to CSV file
    if 'Pandas' in file_path:
      df = pd.read_csv(file_path)#, header=None)    
      xData = df['Wavelength']
      yData = df['Channel-1']
      xFilterData, yFilterData = Filter_Data(xData= xData, yData= yData, xStart=1535, xStop= 1560)
      xFilterData = xFilterData.to_numpy()
      yFilterData = yFilterData.to_numpy()
      axs[1,0].plot(xFilterData, yFilterData)#type: ignore
      legend_val = df['Device-ID'][0]
      Legend_lables= np.append(Legend_lables, legend_val)

  axs[1,0].set_title('Channel-1')#type: ignore
  axs[1,0].legend(Legend_lables, loc='center left', bbox_to_anchor=(1, 0.5),fontsize = 7)#type: ignore
  axs[1,0].set_ylim([-55, 10])#type: ignore
  axs[1,0].set_ylabel("Transmission (dB)")#type: ignore
  axs[1,0].set_xlabel("Wavelength (nm)")#type: ignore


  ''' Channel 1 Fitted result'''
  Legend_lables = list()
  lambda_resonant_Channel1 = dict()
  dB_resonant_Channel1 = dict()
  for file_path in all_csv_files:                 # Finding the path to CSV file
    if 'Pandas' in file_path:
      df = pd.read_csv(file_path)#, header=None)    
      xData = df['Wavelength']
      yData = df['Channel-1']
      xFilterData, yFilterData = Filter_Data(xData= xData, yData= yData, xStart=1535, xStop= 1560)
      xFilterData = xFilterData.to_numpy()
      yFilterData = yFilterData.to_numpy()
      # Curve_Fit_Loren, min_dB, min_lambda = Loren_Model_Channel1(xFilterData, yFilterData) #type: ignore
      
      # axs[1,1].plot(xFilterData, Curve_Fit_Loren)#type: ignore
      legend_val = df['Device-ID'][0]
      
      # lambda_resonant_Channel1[legend_val] = min_lambda
      # dB_resonant_Channel1[legend_val] = min_dB

      Legend_lables= np.append(Legend_lables, legend_val)

  # print("min Value for dB ::", dB_resonant_Channel1)
  # print("min Value for lambda ::", lambda_resonant_Channel1)
  axs[1,1].set_title('Channel-1 -- Fit')#type: ignore
  axs[1,1].legend(Legend_lables, loc='center left', bbox_to_anchor=(1, 0.5),fontsize = 7) #type: ignore
  axs[1,1].set_ylim([-55, 10])#type: ignore
  axs[1,1].set_ylabel("Transmission (dB)")#type: ignore
  axs[1,1].set_xlabel("Wavelength (nm)")#type: ignore

  ''' Channel 1 min values '''
  Legend_lables = list()
  for i in dB_resonant_Channel1:
    axs[1,2].scatter(lambda_resonant_Channel1[i], dB_resonant_Channel1[i]) #type: ignore
    Legend_lables= np.append(Legend_lables, i)

  axs[1,2].set_title('Channel-1 -- Fit')#type: ignore
  axs[1,2].legend(Legend_lables, loc='center left', bbox_to_anchor=(1, 0.5),fontsize = 7) #type: ignore
  axs[1,2].set_ylim([-55, 10])#type: ignore
  axs[1,2].set_ylabel("Transmission (dB)")#type: ignore
  axs[1,2].set_xlabel("Wavelength (nm)")#type: ignore


  # ''' Channel 2 output result'''
  # Legend_lables = list()
  # for file_path in all_csv_files:                 # Finding the path to CSV file
  #   if 'Pandas' in file_path:
  #     df = pd.read_csv(file_path)#, header=None)    
  #     xData = df['Wavelength']
  #     yData = df['Channel-2']
  #     xFilterData, yFilterData = Filter_Data(xData= xData, yData= yData, xStart=1535, xStop= 1560)
  #     xFilterData = xFilterData.to_numpy()
  #     yFilterData = yFilterData.to_numpy()
  #     axs[2,0].plot(xFilterData, yFilterData)#type: ignore
  #     legend_val = df['Device-ID'][0]
  #     Legend_lables= np.append(Legend_lables, legend_val)

  # axs[2,0].set_title('Channel-2')#type: ignore
  # axs[2,0].legend(Legend_lables, loc='center left', bbox_to_anchor=(1, 0.5),fontsize = 7)#type: ignore
  # axs[2,0].set_ylim([-55, 10])#type: ignore
  # axs[2,0].set_ylabel("Transmission (dB)")#type: ignore
  # axs[2,0].set_xlabel("Wavelength (nm)")#type: ignore


  # ''' Channel 2 Fitted result'''
  # Legend_lables = list()
  # for file_path in all_csv_files:                 # Finding the path to CSV file
  #   if 'Pandas' in file_path:
  #     df = pd.read_csv(file_path)#, header=None)    
  #     xData = df['Wavelength']
  #     yData = df['Channel-2']
  #     xFilterData, yFilterData = Filter_Data(xData= xData, yData= yData, xStart=1535, xStop= 1560)
  #     xFilterData = xFilterData.to_numpy()
  #     yFilterData = yFilterData.to_numpy()
  #     Curve_Fit_Loren = Loren_Model_Channel2(xFilterData, yFilterData)
  #     axs[2,1].plot(xFilterData, Curve_Fit_Loren) #type: ignore
  #     legend_val = df['Device-ID'][0]
  #     Legend_lables= np.append(Legend_lables, legend_val)

  # axs[2,1].set_title('Channel-2 -- Fit')#type: ignore
  # axs[2,1].legend(Legend_lables, loc='center left', bbox_to_anchor=(1, 0.5),fontsize = 7)#type: ignore
  # axs[2,1].set_ylim([-55, 10])#type: ignore
  # axs[2,1].set_ylabel("Transmission (dB)")#type: ignore
  # axs[2,1].set_xlabel("Wavelength (nm)")#type: ignore

  fig.tight_layout(pad=4.0)
  plt.show()
  # print('Success')
  return()

def Filter_Pandas (folder_path, Search_Range = 1000):
  '''
  The goal of this function is to ensure that the user can run simulations in specific 
  regions of the map. There are 5 pre-defined regions that the user can use. 
  0: Center of the die 
  1: Top Right corner 
  2: Top Left corner 
  3: Bottom Left corner 
  4: Bottom Right corner
  The user further has options to define the range of the search in all these regions. 
  If the user sets range value to be '-1' it scans the whole chip. 

  The function simply returns a list of all the devices specific to that region.
  '''
  Range = Search_Range/2 

  if Range > 4499.9999 or Range < 0:
    print("Showing all the devices on the die")
    Position = 0
    Range = 4500 # Restricted to this particular chip
  else :
    Position = input("Position of the devices \n 0: Center \n 1: Top Right \n 2: Top Left \n 3: Bottom Left \n 4: Bottom Right \n Enter Here ----->")

  # Need to add checkers here to ensure that we are within the limit and 
  # making sure that the input which was entered is an int value
  Position = int(Position)

  if Position == 0: # Center 
    X_min = -Range
    X_max = Range
    Y_min = -Range 
    Y_max = Range 
  elif Position == 1: # Top Right 
    X_min = 4500 - (Range *2)
    X_max = 4500
    Y_min = 4500 - (Range *2)
    Y_max = 4500
  elif Position == 2: # Top Left
    X_min = -4500
    X_max = -4500 + (Range *2)
    Y_min = 4500 - (Range *2)
    Y_max = 4500 
  elif Position == 3: # Bottom Left
    X_min = -4500
    X_max = -4500 + (Range *2)
    Y_min = -4500 
    Y_max = -4500 + (Range *2)
  elif Position == 4: # Bottom Right 
    X_min = 4500 - (Range *2)
    X_max = 4500
    Y_min = -4500 
    Y_max = -4500 + (Range *2)

  # print("X_min -->", X_min)
  # print("X_max -->", X_max)
  # print("Y_min -->", Y_min)
  # print("Y_max -->", Y_max)

  PATH = folder_path
  EXT = "*.csv"
  all_csv_files = [file
                  for path, subdir, files in os.walk(PATH)
                  for file in glob(os.path.join(path, EXT))]
  
  filtered_list = list()
  for file_path in all_csv_files:                 # Finding the path to CSV file
    if 'Pandas' in file_path:
      
      df = pd.read_csv(file_path)#, header=None) # Read the respective file 

      # Reading Respective Cordinate values 
      X_Coord = df['X-Coordinate'][0]
      Y_Coord = df['Y-Coordinate'][0]

      if X_max > X_Coord and X_Coord > X_min :#type: ignore
         if Y_max > Y_Coord and Y_Coord > Y_min:#type: ignore
          # print("X-Value =", X_Coord, "and Y-Value =", Y_Coord)
          filtered_list.append(file_path)

  # pprint(filtered_list)
  return(filtered_list)

def Plot_Data (all_csv_files, Show_Plot = False):
  '''
  The goal of this function is to plot data. 
  Input given to this function is a list of all the devices which 
  needs to be plotted and the function return mean and std dev values 
  of all the devices which were given to it. 
  '''

  fig, axs = plt.subplots(1, 3, figsize=(15, 5))

  ''' Channel 1 output result'''
  Legend_lables = list()
  for file_path in all_csv_files:                 # Finding the path to CSV file
    if 'Pandas' in file_path:
      df = pd.read_csv(file_path)#, header=None)    
      # axs[0].plot(df['Wavelength'], df['Laser-Power(dB)'], color = 'green')
      axs[0].plot(df['Wavelength'], df['Channel-1'])#type: ignore
      legend_val = df['Device-ID'][0]
      Legend_lables= np.append(Legend_lables, legend_val)

  axs[0].set_title('Channel-1')#type: ignore
  # axs[0].legend(Legend_lables, loc='center left', bbox_to_anchor=(1, 0.5),fontsize = 7)
  axs[0].set_ylim([-55, 10])#type: ignore
  axs[0].set_ylabel("Transmission (dB)")#type: ignore
  axs[0].set_xlabel("Wavelength (nm)")#type: ignore

  ''' Channel 2 output result'''
  Legend_lables = list()
  for file_path in all_csv_files:                 # Finding the path to CSV file
    if 'Pandas' in file_path:
      df = pd.read_csv(file_path)#, header=None)    
      # axs[1].plot(df['Wavelength'], df['Laser-Power(dB)'], color = 'green')
      axs[1].plot(df['Wavelength'], df['Channel-2'])#type: ignore
      legend_val = df['Device-ID'][0]
      Legend_lables= np.append(Legend_lables, legend_val)

  axs[1].set_title('Channel-2')#type: ignore
  # axs[1].legend(Legend_lables, loc='center left', bbox_to_anchor=(1, 0.5),fontsize = 7)
  axs[1].set_ylim([-55, 10])#type: ignore
  axs[1].set_ylabel("Transmission (dB)")#type: ignore
  axs[1].set_xlabel("Wavelength (nm)")#type: ignore

  ''' Location of the Device on the chip '''
  Legend_lables = list()
  for file_path in all_csv_files:                 # Finding the path to CSV file
    if 'Pandas' in file_path:
      df = pd.read_csv(file_path)#, header=None)    
      axs[2].plot(df['X-Coordinate'][0], df['Y-Coordinate'][0], # type: ignore 
                    color = 'red', marker='o', markerfacecolor='green')
      legend_val = df['Device-ID'][0]
      true_legend = legend_val.split('_')
      true_legend= '_'.join([true_legend[1],true_legend[2]])
      Legend_lables= np.append(Legend_lables, true_legend)
      
  axs[2].set_title('Selected Devices')  # type: ignore
  # axs[2].legend(Legend_lables, loc='center left', bbox_to_anchor=(1, 0.5),fontsize = 7)
  axs[2].set_xlim([-4600, 4600])#type: ignore
  axs[2].set_ylim([-4600, 4600])#type: ignore
  axs[2].set_ylabel("Y-Axis")#type: ignore
  axs[2].set_xlabel("X-Axis")#type: ignore


  if Show_Plot == True:
    plt.show()

def Fitted_Plot_Data (all_csv_files, Show_Plot = False):

  ''' This Function is to plot the fitted data and calculate the mean and std
      of the data which is present. '''

  fig, axs = plt.subplots(1, 3, figsize=(15, 5))
  ''' Channel 1 output result'''
  Legend_lables = list()
  for file_path in all_csv_files:                 # Finding the path to CSV file
    if 'Pandas' in file_path:
      df = pd.read_csv(file_path)#, header=None)    
      xData = df['Wavelength']
      yData = df['Channel-1']
      xFilterData, yFilterData = Filter_Data(xData= xData, yData= yData, xStart=1535, xStop= 1560)
      xFilterData = xFilterData.to_numpy()
      yFilterData = yFilterData.to_numpy()
      axs[0].plot(xFilterData, yFilterData)#type: ignore
      legend_val = df['Device-ID'][0]
      Legend_lables= np.append(Legend_lables, legend_val)

  axs[0].set_title('Channel-1')#type: ignore
  # axs[0].legend(Legend_lables, loc='center left', bbox_to_anchor=(1, 0.5),fontsize = 7)#type: ignore
  axs[0].set_ylim([-55, 10])#type: ignore
  axs[0].set_ylabel("Transmission (dB)")#type: ignore
  axs[0].set_xlabel("Wavelength (nm)")#type: ignore


  ''' Channel 1 Fitted result'''
  Legend_lables = list()
  lambda_resonant_Channel1 = dict()
  dB_resonant_Channel1 = dict()

  for file_path in all_csv_files:                 # Finding the path to CSV file
    if 'Pandas' in file_path:
      df = pd.read_csv(file_path)#, header=None)    
      xData = df['Wavelength']
      yData = df['Channel-1']
      xFilterData, yFilterData = Filter_Data(xData= xData, yData= yData, xStart=1535, xStop= 1565)
      xFilterData = xFilterData.to_numpy()
      yFilterData = yFilterData.to_numpy()
      # print(file_path)
      try:
        Curve_Fit_Loren, min_dB, min_lambda = Loren_Model_Channel1(xFilterData, yFilterData) #type: ignore
        axs[1].plot(xFilterData, Curve_Fit_Loren)#type: ignore
        legend_val = df['Device-ID'][0]
        
        lambda_resonant_Channel1[legend_val] = min_lambda #type: ignore
        dB_resonant_Channel1[legend_val] = min_dB #type: ignore

        Legend_lables= np.append(Legend_lables, legend_val)
      except ValueError:
        print("Skiiping") 
      
      

  # Writing devices to a dictionary for easy reading and accessibility
  print(lambda_resonant_Channel1)
  print("Length of the channel is ::", len(lambda_resonant_Channel1))
  # sys.exit()
  if not os.path.exists("Output"):
    os.mkdir("Output")
  # field_names = ["Device_ID", "Min_Lambda"]

  with open('Output/MR1_Minimum_Lambda.csv', 'w') as csvfile:
    writer = csv.writer(csvfile)
    for key, value in lambda_resonant_Channel1.items():
       writer.writerow([key, value])



  # print("min Value for dB ::", dB_resonant_Channel1)
  # print("min Value for lambda ::", lambda_resonant_Channel1)
  # axs[1].set_title('Channel-1 -- Fit')#type: ignore
  # # axs[1].legend(Legend_lables, loc='center left', bbox_to_anchor=(1, 0.5),fontsize = 7) #type: ignore
  # axs[1].set_ylim([-55, 10])#type: ignore
  # axs[1].set_ylabel("Transmission (dB)")#type: ignore
  # axs[1].set_xlabel("Wavelength (nm)")#type: ignore

  ''' Channel 1 min values '''
  Legend_lables = list()
  for i in dB_resonant_Channel1:
    axs[1].scatter(lambda_resonant_Channel1[i], dB_resonant_Channel1[i]) #type: ignore
    Legend_lables= np.append(Legend_lables, i)

  axs[1].set_title('Channel-1 -- Fit')#type: ignore
  # axs[2].legend(Legend_lables, loc='center left', bbox_to_anchor=(1, 0.5),fontsize = 7) #type: ignore
  axs[1].set_ylim([-55, 10])#type: ignore
  axs[1].set_ylabel("Transmission (dB)")#type: ignore
  axs[1].set_xlabel("Wavelength (nm)")#type: ignore

  # Scatter Plot 
  for file_path in all_csv_files:                 # Finding the path to CSV file
    if 'Pandas' in file_path:
      df = pd.read_csv(file_path)#, header=None)    
      axs[2].plot(df['X-Coordinate'][0], df['Y-Coordinate'][0], # type: ignore 
                    color = 'red', marker='o', markerfacecolor='green')
      legend_val = df['Device-ID'][0]
      true_legend = legend_val.split('_')
      true_legend= '_'.join([true_legend[1],true_legend[2]])
      Legend_lables= np.append(Legend_lables, true_legend)
      
  axs[2].set_title('Selected Devices')  # type: ignore
  # axs[2].legend(Legend_lables, loc='center left', bbox_to_anchor=(1, 0.5),fontsize = 7)
  axs[2].set_xlim([-4600, 4600])#type: ignore
  axs[2].set_ylim([-4600, 4600])#type: ignore
  axs[2].set_ylabel("Y-Axis")#type: ignore
  axs[2].set_xlabel("X-Axis")#type: ignore

  # Here we are just trying to calculate the mean and std values of given spectrum 

  dB_list = list()
  lambda_list = list()
  for i in lambda_resonant_Channel1:
    counter = 0
    for lambda_val in lambda_resonant_Channel1[i]:
      
      if 1542 < lambda_val < 1550:
        lambda_list.append(lambda_val)
        dB_list.append(dB_resonant_Channel1[i][counter])

      counter = counter +1
  
  # # Need to calculate the mean and std deviation of the following lists. 
  # print("The std dev of the list is: ",stat.stdev(dB_list), "dB \nThe mean of the list is: ", stat.mean(dB_list), "dB")
  # print("The std dev of the list is: ",stat.stdev(lambda_list), "nm \nThe mean of the list is: ", stat.mean(lambda_list), "nm")
  # print(lambda_list)
  mean_dB = round(stat.mean(dB_list),3)
  std_dB = round(stat.stdev(dB_list),3)

  mean_lambda = round(stat.mean(lambda_list),3)
  std_lambda = round(stat.stdev(lambda_list),3)

  fig.tight_layout(pad=4.0)
  # print("Total Number of Devices :", len(lambda_list))
  print("mean_dB:", mean_dB, "dB \nstd_dB:", std_dB, "dB \nmean_lambda:", mean_lambda, "nm \nstd_lambda:", std_lambda, "nm")
  
  if Show_Plot == True:
    plt.show()

  return(mean_dB, std_dB, mean_lambda, std_lambda)

def Distance_Resonant_Shift (all_csv_files, Show_Plot = False):

  ''' This function helps with calculating data for plotting distance vs 
  resonatnt wavelength shift  '''
  
  List1 = all_csv_files[:-1]
  List2 = all_csv_files[1:]

  Lambda_Diff_arr = list()
  Dist_Diff_arr = list()

  for i_file_path in List1:
    i_df = pd.read_csv(i_file_path)#, header=None)
    
    # Location of the first device 
    i_XLoc = i_df['X-Coordinate'][0]
    i_YLoc = i_df['Y-Coordinate'][0]
    i_Loc = [i_XLoc,i_YLoc]

    i_xData = i_df['Wavelength']
    i_yData = i_df['Channel-1']
    i_xFilterData, i_yFilterData = Filter_Data(xData= i_xData, yData= i_yData, xStart=1543, xStop= 1550)
    i_xFilterData = i_xFilterData.to_numpy()
    i_yFilterData = i_yFilterData.to_numpy()
    # print(i_file_path)
    try:
      i_Curve_Fit_Loren, i_min_dB, i_min_lambda = Loren_Model_Channel1(i_xFilterData, i_yFilterData) #type: ignore
      i_min_lambda = np.sort(i_min_lambda)
      Lambda1_Val = i_min_lambda[0] # Just looking at the first value.

      for j_file_path in List2:
        
        j_df = pd.read_csv(j_file_path)#, header=None)
        # Location of the second device 
        j_XLoc = j_df['X-Coordinate'][0]
        j_YLoc = j_df['Y-Coordinate'][0]
        j_Loc = [j_XLoc,j_YLoc]

        j_xData = j_df['Wavelength']
        j_yData = j_df['Channel-1']
        j_xFilterData, j_yFilterData = Filter_Data(xData= j_xData, yData= j_yData, xStart=1543, xStop= 1550)
        j_xFilterData = j_xFilterData.to_numpy()
        j_yFilterData = j_yFilterData.to_numpy()
        print(j_file_path)

        try:
          j_Curve_Fit_Loren, j_min_dB, j_min_lambda = Loren_Model_Channel1(j_xFilterData, j_yFilterData) #type: ignore
          j_min_lambda = np.sort(j_min_lambda)
          Lambda2_Val = j_min_lambda[0] # Just looking at the first value.

          # now calculate the distance between two
          
          # Dist = math.dist(i_Loc, j_Loc)
          Dist = Cal_dist(i_Loc, j_Loc)
          Dist = round(Dist, 3)

          if Dist == 0:
            continue
          
          # print("The distance between two is", Dist)

          Lambda_Diff = abs(Lambda1_Val-Lambda2_Val)
          Lambda_Diff = round(Lambda_Diff, 3)
          # print("Lambda Diff Value is = ", Lambda_Diff)     

          # Temp_Dist = [Dist, Lambda_Diff]

          Lambda_Diff_arr = np.append(Lambda_Diff_arr, Lambda_Diff)
          Dist_Diff_arr = np.append(Dist_Diff_arr, Dist)

          # Lambda_vs_Dist = np.append(Lambda_vs_Dist, Temp_Dist, axis=0)

        except ValueError:
          print("Skiiping") 
      
      List2 = List2[1:] # Reducing the size of the list 
    except ValueError:
      print("Skiiping") 

  dict_to_write = {'Lambda_Diff':Lambda_Diff_arr, 'Distance': Dist_Diff_arr}
  df = pd.DataFrame(dict_to_write)

  if not os.path.exists("Output"):
    os.mkdir("Output")
  # field_names = ["Device_ID", "Min_Lambda"]

  # Writing the output the respective file
  df.to_csv('Output/Dist_vs_LambdaDiff_M4_25C.csv', header=True, index= False)

  # Plotting the data for easy visualization

  # fig, axs = plt.subplots(1, 2, figsize=(5, 5))

  for i in range(len(Lambda_Diff_arr)):
    plt.scatter(Lambda_Diff_arr[i], Dist_Diff_arr[i]) #type: ignore

  plt.title('Delta Lambda vs Distance Diff')#type: ignore
  # plt.legend(Legend_lables, loc='center left', bbox_to_anchor=(1, 0.5),fontsize = 7) #type: ignore
  # plt.set_ylim([-55, 10])#type: ignore
  plt.ylabel("Delta Lambda (um)")#type: ignore
  plt.xlabel("Distance (nm)")#type: ignore

  if Show_Plot == True:
    plt.show()

  return(Lambda_Diff_arr, Dist_Diff_arr)

def Cal_dist (p1, p2):
  ''' 
  Calcualate distance between two points 
  
  # Input:
    Two points A and B in our case p1 and p2

  # Output:
    The distance between these two parts
  '''
  distance = math.sqrt( ((p1[0]-p2[0])**2)+((p1[1]-p2[1])**2) )
  return(distance)

def Plot_Dist_vs_Lambda(Output_File_Name, Show_Plot = False):

  '''
  This function helps with just plotting
  The plot generates Change in lambda (Delta Lambda) vs distance between two MRs
  
  # Inputs 
    Name of the file with two columns Lambda Diff and Dist

  # Output :
    Output plot which has been generated. 
  '''

  df = pd.read_csv(Output_File_Name)#, header=None) 
  xData = df['Distance']
  yData = df['Lambda_Diff']

  # for i in range(len(xData)):
  plt.scatter(xData, yData, c='Blue') #type: ignore

  plt.title('Delta Lambda vs Distance Diff--M4')#type: ignore
  # plt.legend(Legend_lables, loc='center left', bbox_to_anchor=(1, 0.5),fontsize = 7) #type: ignore
  # plt.set_ylim([-55, 10])#type: ignore
  plt.ylabel("Delta Lambda (nm)")#type: ignore
  plt.xlabel("Distance (um)")#type: ignore
  if Show_Plot == True:
    plt.show()
  print("Done Printing")
  return()


def Q_factor_Calc (all_csv_files, Min_Val = 1545, Max_Val = 1555, Output_File_Name = "Test_File", Show_Plot = False):

  '''
  This function helps with calculating Q-factor, ER, min lambda, and min dB value and 
  outputs a .json file. The json file can then be read to calculate
  '''

  ''' Channel 1 Fitted result'''
  Legend_lables = list()
  Q_factor_array = np.empty(0,)
  ER_array = np.empty(0,)
  Min_Lambda = np.empty(0,)
  Main_Dict = dict()

  ''' Splitting the string '''
  MR_Name = Output_File_Name.split("_") # Naming for plotting.
  TITLE_FONTSIZE =16
  AXIS_FONTSIZE =12
  
  fig, axs = plt.subplots(1, 3, figsize=(15, 5))
  for file_path in all_csv_files:                 # Finding the path to CSV file
    
    Temp_Dict = {}
    if 'Pandas' in file_path:
      df = pd.read_csv(file_path)#, header=None)    
      xData = df['Wavelength']
      yData = df['Channel-1']
      x_Cordinate = df['X-Coordinate'][0] # X-Coordinate value
      y_Cordinate = df['Y-Coordinate'][0] # Y-Coordinate value
      
      xFilterData, yFilterData = Filter_Data(xData= xData, yData= yData, xStart=Min_Val, xStop= Max_Val)
      xFilterData = xFilterData.to_numpy()
      yFilterData = yFilterData.to_numpy()
      try:
        Curve_Fit_Loren, min_dB, min_lambda = Loren_Model_Channel1(xFilterData, yFilterData) #type: ignore

        axs[0].plot(xFilterData, Curve_Fit_Loren) #type: ignore
        axs[0].set_xlabel('Wavelength (in nm)', fontsize = AXIS_FONTSIZE)
        axs[0].set_ylabel('Transmission (in dB)', fontsize = AXIS_FONTSIZE)
        axs[0].set_title(MR_Name[0]+'-'+MR_Name[1]+'-- Transmission Spectrum', fontsize = TITLE_FONTSIZE)

        legend_val = df['Device-ID'][0]

        max_dB_val = max(Curve_Fit_Loren) # Maximum power 
        min_dB_val = min(Curve_Fit_Loren) # Minimum power 

        index_num = Curve_Fit_Loren.index(min_dB_val)
        

        ''' Calculating Corresponding FWHM Value '''
        FWHM = (min_dB_val+max_dB_val)/2
        FWHM = round(FWHM, 5)

        ''' Finding index value of left and right side of FWHM spectrum '''
        left_FWHM = np.argmin(np.abs(np.array(Curve_Fit_Loren)-FWHM)) 
        right_FWHM = (index_num - left_FWHM) + index_num


        Delta_Lambda = abs(xFilterData[left_FWHM]-xFilterData[right_FWHM])
        Q_factor = min_lambda/Delta_Lambda
        Q_factor = Q_factor.tolist()
        Q_factor_array = np.append(Q_factor_array,Q_factor)

        ''' Calculating Extinction Ratio Value '''
        ER_Value = max_dB_val-min_dB
        ER_Value = ER_Value.tolist()
        ER_array = np.append(ER_array,ER_Value)
        Min_Lambda = np.append(Min_Lambda, min_lambda)

        ''' Writing Results into a dictionary'''
        Temp_Dict["Central_Lambda"] = min_lambda[0]
        Temp_Dict["ER"] = ER_Value[0]
        Temp_Dict["Q-factor"] = Q_factor[0]
        Temp_Dict["Min_Power"] = min_dB[0]
        Temp_Dict["X-Coordinate"] =x_Cordinate
        Temp_Dict["Y-Coordinate"] =y_Cordinate

        Main_Dict[legend_val] = Temp_Dict

        Legend_lables= np.append(Legend_lables, legend_val)
        
      except ValueError:
        print("Skiiping") 

  with open('Output/'+Output_File_Name+'.json', 'w') as f:
    json.dump(Main_Dict, f)

  print("Files Written to Output folder")  

  print("Mean of Q-factor is:", np.mean(Q_factor_array))
  print("Std-Dev of Q-factor is:", np.std(Q_factor_array))
  print("Mean of ER is:", np.mean(ER_array))
  print("Std-Dev of ER is:", np.std(ER_array))

  axs[1].scatter(Min_Lambda, Q_factor_array) #type: ignore
  axs[1].set_xlabel('Wavelength (in nm)', fontsize = AXIS_FONTSIZE)
  axs[1].set_ylabel('Q-factor', fontsize = AXIS_FONTSIZE)
  axs[1].set_title(MR_Name[0]+'-'+MR_Name[1]+'-- Q-factor Analysis', fontsize = TITLE_FONTSIZE)


  axs[2].scatter(Min_Lambda, ER_array) #type: ignore
  axs[2].set_xlabel('Wavelength (in nm)', fontsize = AXIS_FONTSIZE)
  axs[2].set_ylabel('Extinction Ratio (dB)', fontsize = AXIS_FONTSIZE)
  axs[2].set_title(MR_Name[0]+'-'+MR_Name[1]+'-- ER Analysis', fontsize = TITLE_FONTSIZE)

  if Show_Plot == True:
    plt.show()

  return()


if __name__ == '__main__':


  Convert_to_Pandas(folder_path= "C:/Users/luxia/OneDrive/sweepLaser/MR1/MR1_100_1")
  print("----------File Successfully Written----------")

  Channel1_Sep(folder_path="C:/Users/luxia/OneDrive/sweepLaser/MR1/MR1_100_1")
  print("-----file filtered----------")

  Plot_All_Pandas(folder_path= "C:/Users/luxia/OneDrive/sweepLaser/MR1/MR1_100_1")
  print("----------File Plotted----------")
  # Convert_to_Pandas(folder_path='C:/Users/luxia/Downloads/Testing_Station_Data_Extraction-Interns_2023/test4')
  # print("-------------File Successfully Written------------")

  # Plot_All_Pandas(folder_path="C:/Users/luxia/Downloads/Testing_Station_Data_Extraction-Interns_2023/test4")
  # print("----file plotted---------")

  # Filtering all the devices you want to plot 
  # List_of_Devices = Filter_Pandas(folder_path= 'test5', Search_Range= -1)
  # List_of_Devices = Filter_Pandas(folder_path= 'test2', Search_Range= -1)
  # pprint(List_of_Devices)
  # List_of_Devices = Filter_Pandas(folder_path= 'sweepLaser/MR1', Search_Range= -1)
  
  # Lambda_Diff, Distance = Distance_Resonant_Shift(List_of_Devices, Show_Plot = True)
  
  # # Plot_Data(List_of_Devices, Show_Plot=True)
  # mean_dB, std_dB, mean_lambda, std_lambda = Fitted_Plot_Data(List_of_Devices, Show_Plot=True)

  # To calculate Q-factor use this 
  # Q_factor_Calc(List_of_Devices, 
  #               Min_Val= 1539,
  #               Max_Val= 1549,
  #               Output_File_Name = "Test5_o",
  #               Show_Plot=True)
  # GroupIndex_Calc()

  # Plotting the distance vs Lambda difference 
  # Plot_Dist_vs_Lambda('Output/Dist_vs_LambdaDiff_M4_25C.csv', Show_Plot = True)
